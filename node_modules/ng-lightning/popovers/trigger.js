import { Directive, Input, ElementRef, TemplateRef, ViewContainerRef, Renderer2, ComponentFactoryResolver, Injector, Output, EventEmitter, NgZone } from '@angular/core';
import * as Tether from 'tether';
import 'rxjs/add/operator/take';
import { NglPopover } from './popover';
import { placement } from './placements';
import { toBoolean } from '../util/util';
var NglPopoverTrigger = (function () {
    function NglPopoverTrigger(element, viewContainer, injector, ngZone, renderer, componentFactoryResolver) {
        this.element = element;
        this.viewContainer = viewContainer;
        this.injector = injector;
        this.ngZone = ngZone;
        this.renderer = renderer;
        // Emit an event when actual popover is shown or hidden
        this.nglPopoverToggled = new EventEmitter();
        this.placement = 'top';
        this.openDelay = 0;
        this.closeDelay = 0;
        this.toggleTimeout = null;
        this.interactive = false;
        this.interactiveSubscription = null;
        this.popoverFactory = componentFactoryResolver.resolveComponentFactory(NglPopover);
    }
    Object.defineProperty(NglPopoverTrigger.prototype, "nglPopoverPlacement", {
        set: function (_placement) {
            this.placement = _placement || 'top';
            this.setTether();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglPopoverTrigger.prototype, "nglPopoverTheme", {
        set: function (theme) {
            this.theme = theme;
            this.setPopover();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglPopoverTrigger.prototype, "nglPopoverDelay", {
        set: function (delay) {
            delay = Array.isArray(delay) ? delay : [delay, delay];
            _a = delay.map(Number), this.openDelay = _a[0], this.closeDelay = _a[1];
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglPopoverTrigger.prototype, "nglInteractive", {
        get: function () {
            return this.interactive;
        },
        set: function (interactive) {
            this.interactive = toBoolean(interactive);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglPopoverTrigger.prototype, "nglOpen", {
        set: function (open) {
            this.toggle(open, open ? this.openDelay : this.closeDelay);
        },
        enumerable: true,
        configurable: true
    });
    // Expose open method
    NglPopoverTrigger.prototype.open = function (delay) {
        if (delay === void 0) { delay = this.openDelay; }
        this.toggle(true, delay);
    };
    // Expose close method
    NglPopoverTrigger.prototype.close = function (delay) {
        if (delay === void 0) { delay = this.closeDelay; }
        this.toggle(false, delay);
    };
    NglPopoverTrigger.prototype.position = function (async) {
        var _this = this;
        if (async === void 0) { async = true; }
        this.ngZone.runOutsideAngular(function () {
            if (async) {
                setTimeout(function () { return _this.tether.position(); });
            }
            else {
                _this.tether.position();
            }
        });
    };
    NglPopoverTrigger.prototype.ngOnDestroy = function () {
        this.destroy();
    };
    NglPopoverTrigger.prototype.toggle = function (open, delay) {
        var _this = this;
        if (this.toggleTimeout) {
            clearTimeout(this.toggleTimeout);
            this.toggleTimeout = null;
        }
        var toggleFn = (open ? this.create : this.destroy).bind(this);
        if (delay > 0) {
            this.toggleTimeout = setTimeout(function () {
                _this.toggleTimeout = null;
                toggleFn();
            }, delay);
        }
        else {
            toggleFn();
        }
    };
    NglPopoverTrigger.prototype.setTether = function (create) {
        if (create === void 0) { create = false; }
        if (!this.tether && !create)
            return;
        var _a = placement(this.placement), attachment = _a.attachment, targetAttachment = _a.targetAttachment, offset = _a.offset;
        var options = {
            element: this.popover.element.nativeElement,
            target: this.element.nativeElement,
            attachment: attachment,
            targetAttachment: targetAttachment,
            offset: offset,
        };
        if (create) {
            this.tether = new Tether(options);
        }
        else {
            this.tether.setOptions(options);
        }
        this.setPopover();
    };
    NglPopoverTrigger.prototype.setPopover = function () {
        if (!this.popover)
            return;
        var opposite = placement(this.placement).opposite;
        this.popover.nubbin = opposite;
        this.popover.theme = this.theme;
        this.popover.nglTooltip = this.nglTooltip;
    };
    NglPopoverTrigger.prototype.create = function () {
        var _this = this;
        if (this.componentRef)
            return;
        var _a = this.getProjectableNodes(), nodes = _a.nodes, viewRef = _a.viewRef;
        this.viewRef = viewRef;
        this.componentRef = this.viewContainer.createComponent(this.popoverFactory, 0, this.injector, [nodes]);
        this.popover = this.componentRef.instance;
        this.popover.header = this.nglPopoverHeader;
        this.popover.footer = this.nglPopoverFooter;
        this.popover.afterViewInit.take(1).subscribe(function () { return _this.position(false); });
        if (this.nglInteractive) {
            this.interactiveSubscription = this.popover.onInteraction.subscribe(function (enter) { return _this.nglOpen = enter; });
        }
        this.setTether(true);
        // To avoid unexpected behavior when template "lives" inside an OnPush
        // component, explicitlly request change detection to run on creation.
        this.popover.changeDetector.markForCheck();
        this.nglPopoverToggled.emit(true);
    };
    NglPopoverTrigger.prototype.getProjectableNodes = function () {
        if (this.nglPopover instanceof TemplateRef) {
            var viewRef = this.viewContainer.createEmbeddedView(this.nglPopover);
            return { nodes: viewRef.rootNodes, viewRef: viewRef };
        }
        else {
            return { nodes: [this.renderer.createText(this.nglPopover)] };
        }
    };
    NglPopoverTrigger.prototype.destroy = function () {
        if (!this.componentRef)
            return;
        this.tether.destroy();
        this.tether = null;
        // Cleanup template view
        if (this.viewRef) {
            this.viewContainer.remove(this.viewContainer.indexOf(this.viewRef));
            this.viewRef = null;
        }
        this.viewContainer.remove(this.viewContainer.indexOf(this.componentRef.hostView));
        this.componentRef.destroy();
        this.componentRef = null;
        this.popover = null;
        if (this.interactiveSubscription) {
            this.interactiveSubscription.unsubscribe();
        }
        this.nglPopoverToggled.emit(false);
    };
    NglPopoverTrigger.decorators = [
        { type: Directive, args: [{
                    selector: '[nglPopover]',
                    exportAs: 'nglPopover',
                },] },
    ];
    /** @nocollapse */
    NglPopoverTrigger.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ViewContainerRef, },
        { type: Injector, },
        { type: NgZone, },
        { type: Renderer2, },
        { type: ComponentFactoryResolver, },
    ]; };
    NglPopoverTrigger.propDecorators = {
        'nglPopover': [{ type: Input },],
        'nglPopoverHeader': [{ type: Input },],
        'nglPopoverFooter': [{ type: Input },],
        'nglPopoverPlacement': [{ type: Input },],
        'nglPopoverTheme': [{ type: Input },],
        'nglTooltip': [{ type: Input },],
        'nglPopoverDelay': [{ type: Input },],
        'nglInteractive': [{ type: Input },],
        'nglOpen': [{ type: Input },],
        'nglPopoverToggled': [{ type: Output },],
    };
    return NglPopoverTrigger;
}());
export { NglPopoverTrigger };
;
//# sourceMappingURL=trigger.js.map