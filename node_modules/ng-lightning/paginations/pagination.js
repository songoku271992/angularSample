import { Component, EventEmitter, Input, Output, ChangeDetectionStrategy } from '@angular/core';
import { toBoolean } from '../util/util';
var NglPagination = (function () {
    function NglPagination() {
        this.pages = [];
        this.pageChange = new EventEmitter();
        this.perPage = 10;
        this.limit = 0;
        this.boundaryNumbers = 0;
        this.firstText = 'First';
        this.previousText = 'Previous';
        this.nextText = 'Next';
        this.lastText = 'Last';
        this._boundaryLinks = false;
    }
    Object.defineProperty(NglPagination.prototype, "page", {
        set: function (page) {
            this.current = +page;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglPagination.prototype, "boundaryLinks", {
        get: function () {
            return this._boundaryLinks;
        },
        set: function (boundaryLinks) {
            this._boundaryLinks = toBoolean(boundaryLinks);
        },
        enumerable: true,
        configurable: true
    });
    NglPagination.prototype.hasPrevious = function () {
        return this.current > 1;
    };
    NglPagination.prototype.hasNext = function () {
        return this.current < this.totalPages;
    };
    NglPagination.prototype.goto = function (page) {
        if (page === this.current)
            return;
        this.pageChange.emit(+page);
    };
    NglPagination.prototype.ngOnChanges = function (changes) {
        var _this = this;
        this.totalPages = Math.ceil(+this.total / +this.perPage);
        var _a = this.limits(), start = _a.start, end = _a.end;
        this.pages = this.getPageArray(start, end);
        if (this.boundaryNumbers > 0) {
            if (start > 1) {
                var preGap = this.getPageArray(1, Math.min(start - 1, this.boundaryNumbers));
                var lastGapNumber = +preGap[preGap.length - 1].number;
                if (lastGapNumber < start - 1) {
                    this.pages.unshift(this.getGapPage(lastGapNumber, start));
                }
                (_b = this.pages).unshift.apply(_b, preGap);
            }
            if (end < this.totalPages) {
                var postGap = this.getPageArray(Math.max(this.totalPages - this.boundaryNumbers + 1, end + 1), this.totalPages);
                var firstGapNumber = +postGap[0].number;
                if (firstGapNumber > end + 1) {
                    this.pages.push(this.getGapPage(end, firstGapNumber));
                }
                (_c = this.pages).push.apply(_c, postGap);
            }
        }
        if (this.current > this.totalPages) {
            setTimeout(function () { return _this.goto(_this.totalPages); });
        }
        else if (!this.current && this.totalPages > 0) {
            setTimeout(function () { return _this.goto(1); });
        }
        var _b, _c;
    };
    NglPagination.prototype.pageTrackBy = function (index, page) {
        return page.number;
    };
    Object.defineProperty(NglPagination.prototype, "start", {
        get: function () {
            return Math.min(Math.max(1 + (+this.current - 1) * +this.perPage, 0), +this.total);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglPagination.prototype, "end", {
        get: function () {
            return Math.min(this.start + (+this.perPage - 1), +this.total);
        },
        enumerable: true,
        configurable: true
    });
    NglPagination.prototype.getPageArray = function (start, end) {
        var _this = this;
        return Array.apply(null, { length: end - start + 1 }).map(function (value, index) { return _this.getPage(start + index); });
    };
    NglPagination.prototype.getPage = function (number, disabled) {
        if (disabled === void 0) { disabled = false; }
        return { number: number, disabled: disabled };
    };
    NglPagination.prototype.getGapPage = function (before, after) {
        var isConsecutive = before + 1 === after - 1;
        return this.getPage(isConsecutive ? before + 1 : '...', !isConsecutive);
    };
    /**
     * Calculate first and last visible page numbers
     */
    NglPagination.prototype.limits = function () {
        var start = 1, end = this.totalPages;
        if (this.limit < 1)
            return { start: start, end: end };
        // Current page is displayed in the middle of the visible ones
        start = Math.max(+this.current - Math.floor(+this.limit / 2), 1);
        end = start + +this.limit - 1;
        // Adjust if limit is exceeded
        if (end > this.totalPages) {
            end = this.totalPages;
            start = Math.max(end - +this.limit + 1, 1);
        }
        return { start: start, end: end };
    };
    NglPagination.decorators = [
        { type: Component, args: [{
                    selector: 'ngl-pagination',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: "\n    <div class=\"slds-button-group\" role=\"group\"><button class=\"slds-button slds-button--neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasPrevious()\" (click)=\"goto(1)\">{{firstText}}</button><button class=\"slds-button slds-button--neutral\" [disabled]=\"!hasPrevious()\" (click)=\"goto(current - 1)\">{{previousText}}</button><button class=\"slds-button\" *ngFor=\"let page of pages; trackBy:pageTrackBy\" [ngClass]=\"'slds-button--' + (page.number === current ? 'brand' : 'neutral')\" (click)=\"goto(page.number)\" [disabled]=\"page.disabled\">{{page.number}}</button><button class=\"slds-button slds-button--neutral\" [disabled]=\"!hasNext()\" (click)=\"goto(current + 1)\">{{nextText}}</button><button class=\"slds-button slds-button--neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasNext()\" (click)=\"goto(totalPages)\">{{lastText}}</button></div>\n  ",
                    exportAs: 'nglPagination',
                },] },
    ];
    /** @nocollapse */
    NglPagination.ctorParameters = function () { return []; };
    NglPagination.propDecorators = {
        'page': [{ type: Input },],
        'pageChange': [{ type: Output },],
        'total': [{ type: Input },],
        'perPage': [{ type: Input },],
        'limit': [{ type: Input },],
        'boundaryNumbers': [{ type: Input },],
        'firstText': [{ type: Input },],
        'previousText': [{ type: Input },],
        'nextText': [{ type: Input },],
        'lastText': [{ type: Input },],
        'boundaryLinks': [{ type: Input },],
    };
    return NglPagination;
}());
export { NglPagination };
//# sourceMappingURL=pagination.js.map